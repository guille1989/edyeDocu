#!/usr/bin/env node
import fs from "fs";
import path from "path";
import { spawnSync } from "child_process";
import { pathToFileURL } from "url";
import { createRequire } from "module";

const args = process.argv.slice(2);
const require = createRequire(import.meta.url);

function getArgValue(flag) {
  const eqPrefix = `${flag}=`;
  const eqArg = args.find((arg) => arg.startsWith(eqPrefix));
  if (eqArg) {
    return eqArg.slice(eqPrefix.length);
  }
  const idx = args.indexOf(flag);
  if (idx !== -1 && idx < args.length - 1) {
    return args[idx + 1];
  }
  return null;
}

function hasFlag(flag) {
  return args.includes(flag);
}

function printUsage() {
  const text = [
    "Usage: node scripts/compendio.mjs --locale es|en [--format md|pdf] [--pdf-engine <engine>]",
    "",
    "Examples:",
    "  node scripts/compendio.mjs --locale es",
    "  node scripts/compendio.mjs --locale en --format pdf",
    "  node scripts/compendio.mjs --locale es --format pdf --pdf-engine xelatex",
    "  set PDF_ENGINE=C:\\\\path\\\\to\\\\pdflatex.exe (Windows)",
  ].join("\n");
  console.log(text);
}

const locale = getArgValue("--locale");
const format = getArgValue("--format") || (hasFlag("--pdf") ? "pdf" : "md");

if (hasFlag("--help")) {
  printUsage();
  process.exit(0);
}

if (!locale || !["es", "en"].includes(locale)) {
  console.error("Missing or invalid --locale. Use es or en.");
  printUsage();
  process.exit(1);
}

if (!["md", "pdf"].includes(format)) {
  console.error("Invalid --format. Use md or pdf.");
  printUsage();
  process.exit(1);
}

const root = process.cwd();
const sidebarPath = path.join(root, "sidebars.js");

function normalizeSidebars(mod) {
  let value = mod && mod.default ? mod.default : mod;
  if (typeof value === "function") {
    value = value();
  }
  return value;
}

function tryLoadJiti() {
  try {
    const jiti = require("jiti");
    return jiti(import.meta.url, { interopDefault: true });
  } catch {
    return null;
  }
}

function loadSidebarsWithTransform(filePath) {
  const code = fs.readFileSync(filePath, "utf8");
  const hasExportDefault = /\bexport\s+default\s+/.test(code);
  if (!hasExportDefault) {
    throw new Error("No export default found for fallback loader.");
  }
  const transformed = code
    .replace(/\bexport\s+default\s+/g, "module.exports = ")
    .replace(/\bexport\s+\{[^}]*\};?/g, "");
  const module = { exports: {} };
  const fn = new Function(
    "module",
    "exports",
    "require",
    "process",
    "__dirname",
    "__filename",
    transformed
  );
  fn(module, module.exports, require, process, path.dirname(filePath), filePath);
  return module.exports;
}

async function loadSidebars(filePath) {
  const code = fs.readFileSync(filePath, "utf8");
  const hasImport = /^\s*import\s/m.test(code);
  const hasExportDefault = /^\s*export\s+default\s/m.test(code);

  if (!hasImport && hasExportDefault) {
    try {
      return normalizeSidebars(loadSidebarsWithTransform(filePath));
    } catch {
      // fall through
    }
  }

  const jitiRequire = tryLoadJiti();
  if (jitiRequire) {
    try {
      const mod = jitiRequire(filePath);
      return normalizeSidebars(mod);
    } catch {
      // fall through
    }
  }

  try {
    const mod = require(filePath);
    return normalizeSidebars(mod);
  } catch {
    // fall through
  }

  const fileUrl = pathToFileURL(filePath).href;
  try {
    const mod = await import(fileUrl);
    return normalizeSidebars(mod);
  } catch {
    return normalizeSidebars(loadSidebarsWithTransform(filePath));
  }
}

function collectDocIds(node, list, warnings) {
  if (!node) return;
  if (Array.isArray(node)) {
    for (const item of node) {
      collectDocIds(item, list, warnings);
    }
    return;
  }
  if (typeof node === "string") {
    list.push(node);
    return;
  }
  if (typeof node !== "object") return;

  if (node.type === "category") {
    collectDocIds(node.items, list, warnings);
    return;
  }
  if (node.type === "doc") {
    if (node.id) list.push(node.id);
    else if (node.docId) list.push(node.docId);
    return;
  }
  if (node.type === "autogenerated") {
    warnings.autogenerated = true;
    return;
  }
  if (node.type === "link" || node.type === "html") {
    return;
  }
  if (node.items) {
    collectDocIds(node.items, list, warnings);
  }
}

function splitFrontMatter(text) {
  const lines = text.split(/\r?\n/);
  if (lines[0] !== "---") {
    return { frontMatter: null, body: text };
  }
  for (let i = 1; i < lines.length; i += 1) {
    if (lines[i] === "---") {
      const frontMatter = lines.slice(1, i).join("\n");
      const body = lines.slice(i + 1).join("\n");
      return { frontMatter, body };
    }
  }
  return { frontMatter: null, body: text };
}

function parseIdFromFrontMatter(frontMatter) {
  if (!frontMatter) return null;
  const match = frontMatter.match(/^id:\s*(.+)\s*$/m);
  if (!match) return null;
  let id = match[1].trim();
  if (
    (id.startsWith("\"") && id.endsWith("\"")) ||
    (id.startsWith("'") && id.endsWith("'"))
  ) {
    id = id.slice(1, -1);
  }
  return id.trim();
}

function parseTitleFromFrontMatter(frontMatter) {
  if (!frontMatter) return null;
  const match = frontMatter.match(/^title:\s*(.+)\s*$/m);
  if (!match) return null;
  let title = match[1].trim();
  if (
    (title.startsWith("\"") && title.endsWith("\"")) ||
    (title.startsWith("'") && title.endsWith("'"))
  ) {
    title = title.slice(1, -1);
  }
  return title.trim();
}

function toPosixPath(value) {
  return value.split(path.sep).join("/");
}

function walkDir(dirPath) {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      files.push(...walkDir(fullPath));
    } else if (entry.isFile()) {
      files.push(fullPath);
    }
  }
  return files;
}

function buildDocIdForFile(filePath, baseDir, frontMatterId) {
  const relative = toPosixPath(path.relative(baseDir, filePath));
  const ext = path.extname(relative);
  const noExt = relative.slice(0, -ext.length);
  if (!frontMatterId) {
    return noExt;
  }
  const dirName = path.posix.dirname(noExt);
  if (dirName === ".") {
    return frontMatterId;
  }
  return path.posix.join(dirName, frontMatterId);
}

function buildDocIdMap(baseDir) {
  const files = walkDir(baseDir);
  const map = new Map();
  const duplicates = [];
  for (const filePath of files) {
    const ext = path.extname(filePath).toLowerCase();
    if (ext !== ".md" && ext !== ".mdx") continue;
    const raw = fs.readFileSync(filePath, "utf8");
    const { frontMatter } = splitFrontMatter(raw);
    const fmId = parseIdFromFrontMatter(frontMatter);
    const docId = buildDocIdForFile(filePath, baseDir, fmId);
    if (map.has(docId)) {
      const existing = map.get(docId);
      const existingExt = path.extname(existing).toLowerCase();
      if (existingExt !== ext && ext === ".mdx") {
        map.set(docId, filePath);
      }
      duplicates.push(docId);
      continue;
    }
    map.set(docId, filePath);
  }
  return { map, duplicates };
}

function stripLeadingH1(body) {
  const lines = body.split(/\r?\n/);
  let i = 0;
  while (i < lines.length && lines[i].trim() === "") {
    i += 1;
  }
  if (i < lines.length && /^#\s+/.test(lines[i])) {
    const heading = lines[i].replace(/^#\s+/, "").trim();
    i += 1;
    while (i < lines.length && lines[i].trim() === "") {
      i += 1;
    }
    return { heading, body: lines.slice(i).join("\n") };
  }
  return { heading: null, body };
}

function stripDocVersionBlock(body) {
  const lines = body.split(/\r?\n/);
  let start = 0;
  while (start < lines.length && lines[start].trim() === "") {
    start += 1;
  }
  if (start >= lines.length) return body;

  const versionLine = lines[start].trim();
  if (!/^\*\*Versi[^*]*:\*\*/i.test(versionLine)) return body;

  let dateLineIndex = start + 1;
  while (dateLineIndex < lines.length && lines[dateLineIndex].trim() === "") {
    dateLineIndex += 1;
  }
  if (dateLineIndex >= lines.length) return body;

  const dateLine = lines[dateLineIndex].trim();
  if (!/^\*\*Fecha:\*\*/i.test(dateLine)) return body;

  let end = dateLineIndex + 1;
  while (end < lines.length && lines[end].trim() === "") {
    end += 1;
  }
  if (end < lines.length && /^(---|\*\*\*)$/.test(lines[end].trim())) {
    end += 1;
    while (end < lines.length && lines[end].trim() === "") {
      end += 1;
    }
  }

  return lines.slice(end).join("\n");
}

function titleFromDocId(docId) {
  const base = docId.split("/").filter(Boolean).pop() || docId;
  return base
    .split(/[-_]/g)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function extractTitleAndBody(raw, docId) {
  const { frontMatter, body } = splitFrontMatter(raw);
  const fmTitle = parseTitleFromFrontMatter(frontMatter);
  const cleanedBody = stripDocVersionBlock(body);
  const { heading, body: bodyNoH1 } = stripLeadingH1(cleanedBody);
  const title = fmTitle || heading || titleFromDocId(docId);
  return { title, body: bodyNoH1 };
}

function buildSection(title, body) {
  const trimmedBody = body.replace(/\s+$/g, "");
  if (trimmedBody.length === 0) {
    return `# ${title}`;
  }
  return `# ${title}\n\n${trimmedBody}`;
}

function rewriteAbsoluteImagePaths(markdown) {
  const updated = markdown.replace(/!\[([^\]]*)\]\(\/img\//g, "![$1](img/");
  return updated.replace(/src=(["'])\/img\//g, "src=$1img/");
}

function pandocAvailable() {
  const check = spawnSync("pandoc", ["--version"], { stdio: "ignore" });
  if (check.error && check.error.code === "ENOENT") return false;
  return check.status === 0;
}

function findExecutableOnPath(name) {
  const pathEnv = process.env.PATH || "";
  const pathExt =
    process.platform === "win32"
      ? (process.env.PATHEXT || ".EXE;.CMD;.BAT").split(";")
      : [""];
  const hasExt = path.extname(name) !== "";
  const names =
    process.platform === "win32" && !hasExt
      ? pathExt.map((ext) => `${name}${ext}`)
      : [name];
  for (const dir of pathEnv.split(path.delimiter)) {
    if (!dir) continue;
    for (const candidate of names) {
      const fullPath = path.join(dir, candidate);
      if (fs.existsSync(fullPath)) return fullPath;
    }
  }
  return null;
}

function findTexLiveExecutable(name) {
  if (process.platform !== "win32") return null;
  const root = "C:\\texlive";
  if (!fs.existsSync(root)) return null;
  const years = fs
    .readdirSync(root, { withFileTypes: true })
    .filter((entry) => entry.isDirectory() && /^\d{4}$/.test(entry.name))
    .map((entry) => entry.name)
    .sort();
  for (let i = years.length - 1; i >= 0; i -= 1) {
    const candidate = path.join(root, years[i], "bin", "windows", `${name}.exe`);
    if (fs.existsSync(candidate)) return candidate;
  }
  return null;
}

function findLatexExecutable(name) {
  const onPath = findExecutableOnPath(name);
  if (onPath) return onPath;
  if (process.platform !== "win32") return null;

  const programFiles = process.env.ProgramFiles || "C:\\Program Files";
  const programFilesX86 =
    process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)";
  const defaultProgramFiles = "C:\\Program Files";
  const localAppData = process.env.LOCALAPPDATA;
  const miktexRoots = [];
  const miktexBaseDirs = [programFiles, programFilesX86, defaultProgramFiles];
  if (localAppData) {
    miktexBaseDirs.push(path.join(localAppData, "Programs"), localAppData);
  }
  const seenBaseDirs = new Set();
  for (const baseDir of miktexBaseDirs) {
    if (!baseDir || seenBaseDirs.has(baseDir)) continue;
    seenBaseDirs.add(baseDir);
    try {
      const entries = fs.readdirSync(baseDir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isDirectory() && /^MiKTeX/i.test(entry.name)) {
          miktexRoots.push(path.join(baseDir, entry.name));
        }
      }
    } catch {
      // ignore unreadable dirs
    }
  }
  const miktexDirs = [];
  const programFilesCandidates = [
    programFiles,
    defaultProgramFiles,
    programFilesX86,
  ];
  const seenProgramFiles = new Set();
  for (const baseDir of programFilesCandidates) {
    if (!baseDir || seenProgramFiles.has(baseDir)) continue;
    seenProgramFiles.add(baseDir);
    miktexDirs.push(
      path.join(baseDir, "MiKTeX", "miktex", "bin", "x64"),
      path.join(baseDir, "MiKTeX", "miktex", "bin")
    );
  }
  for (const root of miktexRoots) {
    miktexDirs.push(
      path.join(root, "miktex", "bin", "x64"),
      path.join(root, "miktex", "bin")
    );
  }
  for (const dir of miktexDirs) {
    const candidate = path.join(dir, `${name}.exe`);
    if (fs.existsSync(candidate)) return candidate;
  }

  return findTexLiveExecutable(name);
}

function resolvePdfEngine(engineArg) {
  if (engineArg) return engineArg;
  if (process.env.PDF_ENGINE) return process.env.PDF_ENGINE;
  if (process.env.PDFLATEX) return process.env.PDFLATEX;
  const xelatex = findLatexExecutable("xelatex");
  if (xelatex) return xelatex;
  const lualatex = findLatexExecutable("lualatex");
  if (lualatex) return lualatex;
  const pdflatex = findLatexExecutable("pdflatex");
  if (pdflatex) return pdflatex;
  return null;
}

function runPandoc(inputPath, outputPath, options = {}) {
  const args = [inputPath, "-o", outputPath, "--toc", "--from", "markdown-yaml_metadata_block"];
  if (options.resourcePath) {
    args.push("--resource-path", options.resourcePath);
  }
  if (options.pdfEngine) {
    args.push("--pdf-engine", options.pdfEngine);
  }
  const result = spawnSync(
    "pandoc",
    args,
    { stdio: "inherit" }
  );
  return result.status === 0;
}

const sidebars = await loadSidebars(sidebarPath);
const sidebar = sidebars && sidebars.tutorialSidebar ? sidebars.tutorialSidebar : null;

if (!sidebar) {
  console.error("Could not find tutorialSidebar in sidebars.js.");
  process.exit(1);
}

const items = Array.isArray(sidebar) ? sidebar : sidebar.items;
if (!Array.isArray(items)) {
  console.error("tutorialSidebar is not an array.");
  process.exit(1);
}

const warnings = { autogenerated: false };
const docIds = [];
collectDocIds(items, docIds, warnings);

if (warnings.autogenerated) {
  console.warn(
    "Found autogenerated sidebar items. They are not expanded by this script."
  );
}

const baseDir =
  locale === "en"
    ? path.join(root, "i18n", "en", "docusaurus-plugin-content-docs", "current")
    : path.join(root, "docs");

if (!fs.existsSync(baseDir)) {
  console.error(`Docs directory not found: ${baseDir}`);
  process.exit(1);
}

const { map: docIdMap, duplicates: duplicateDocIds } = buildDocIdMap(baseDir);

const missing = [];
const sections = [];

for (const docId of docIds) {
  const resolved = docIdMap.get(docId);
  if (!resolved) {
    missing.push(docId);
    continue;
  }
  const raw = fs.readFileSync(resolved, "utf8");
  const { title, body } = extractTitleAndBody(raw, docId);
  sections.push(buildSection(title, body));
}

if (sections.length === 0) {
  console.error("No documents were found for the requested locale.");
  process.exit(1);
}

const outDir = path.join(root, "dist");
fs.mkdirSync(outDir, { recursive: true });
const outMd = path.join(outDir, `compendio-${locale}.md`);
const resourcePath = [path.join(root, "static"), outDir].join(path.delimiter);
const separator = "\n\n***\n\n\\newpage\n\n";
const output = rewriteAbsoluteImagePaths(sections.join(separator) + "\n");
fs.writeFileSync(outMd, output, "utf8");

console.log(`Wrote ${outMd}`);

if (missing.length > 0) {
  console.warn("Missing docs referenced in sidebar:");
  for (const docId of missing) {
    console.warn(`- ${docId}`);
  }
}

if (duplicateDocIds.length > 0) {
  console.warn("Duplicate doc ids found (preferring .mdx when present):");
  for (const docId of duplicateDocIds) {
    console.warn(`- ${docId}`);
  }
}

if (format === "pdf") {
  const outPdf = path.join(outDir, `compendio-${locale}.pdf`);
  if (!pandocAvailable()) {
    console.warn("Pandoc was not found. Install it and run:");
    console.warn(`pandoc "${outMd}" -o "${outPdf}" --toc`);
    process.exit(0);
  }
  const pdfEngine = resolvePdfEngine(getArgValue("--pdf-engine"));
  if (!pdfEngine) {
    console.warn(
      "No PDF engine found on PATH or standard locations. Use --pdf-engine with a full path."
    );
  }
  const ok = runPandoc(outMd, outPdf, { resourcePath, pdfEngine });
  if (!ok) {
    process.exit(1);
  }
  console.log(`Wrote ${outPdf}`);
}
